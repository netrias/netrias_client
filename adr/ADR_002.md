# ADR 002: Sync Wrapper Event Loop Handling and Step Functions Naming

## Status
Accepted

## Context
During code review of the Data Model Store integration, several issues were identified:

1. **Event loop conflicts**: Sync wrappers using `asyncio.run()` fail with `RuntimeError: This event loop is already running` when called from within an existing async context (Jupyter notebooks, FastAPI, Django async views).

2. **Misleading function names**: The `discover_async` function was named "async" but was actually synchronous/blocking, using `time.sleep()` and sync `httpx.Client` for polling Step Functions.

3. **Security**: The Step Functions execution ARN was being trusted without validating that the region matched the expected deployment region.

4. **Exception hierarchy**: `GatewayBypassError` inherited from `RuntimeError` instead of `NetriasClientError`, breaking the unified exception catching pattern.

5. **Type alias duplication**: `ManifestPayload` was defined identically in both `_client.py` and `_discovery.py`.

## Decision

### 1. Event Loop Detection with ThreadPoolExecutor Fallback
Added `_run_sync()` helper in `_data_model_store.py` and `_discovery.py` that:
- Attempts `asyncio.get_running_loop()` to detect existing loops
- Uses `asyncio.run()` when no loop is running (normal case)
- When a loop is running, delegates to a `ThreadPoolExecutor` that runs `asyncio.run()` in a separate thread

This pattern allows sync methods to work in both standalone scripts and within async frameworks.

### 2. Rename `discover_async` to `discover_via_step_functions` and Module Rename
Renamed the function to clearly indicate:
- It uses Step Functions for execution
- Added docstring NOTE explicitly stating it's blocking/synchronous
- Clarifies that it uses `time.sleep()` for polling, not `asyncio.sleep()`

Additionally renamed `_async_discovery.py` to `_sfn_discovery.py` to eliminate the misleading "async" in the module name since the code is synchronous/blocking.

### 3. Region Validation in ARN Parsing
Added validation in `_extract_region_from_arn()` that checks the extracted region matches `BYPASS_REGION`. This prevents potential security issues where a malicious API could return an ARN pointing to an attacker-controlled region.

### 4. Unified Exception Hierarchy
Changed `GatewayBypassError` to inherit from `NetriasClientError` instead of `RuntimeError`. This allows callers to catch all client-specific errors with a single `except NetriasClientError` clause.

### 5. Centralize Type Aliases
Moved `ManifestPayload` type alias to `_models.py` as the single source of truth. Both `_client.py` and `_discovery.py` now import from there.

### 6. Pagination Guard
Added `MAX_PAGINATION_PAGES = 100` constant and page counter in `get_pv_set_async()` to prevent infinite loops if the API returns malformed pagination responses.

## Consequences

**Benefits:**
- Sync methods now work in Jupyter notebooks and async web frameworks
- Clear naming reduces confusion about blocking vs non-blocking behavior
- Region validation adds defense-in-depth against ARN manipulation
- Unified exception hierarchy simplifies error handling for callers
- Single source of truth for type aliases prevents drift

**Trade-offs:**
- ThreadPoolExecutor adds slight overhead when called from async contexts
- Region validation requires configuration update if deployment region changes

**Migration notes:**
- No API changes for external callers
- Internal function `discover_async` renamed to `discover_via_step_functions` (internal only)
- Internal module `_async_discovery.py` renamed to `_sfn_discovery.py` (internal only)
